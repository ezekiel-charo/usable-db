import { TableRow, TableSchema, ColumnToUpdate } from "./types";

export class Table {
  private rows: TableRow[] = [];
  private unique: Record<string, Record<string, boolean>> = {};

  constructor(public readonly name: string, public schema: TableSchema) {}

  /**
   * Ensures that all column names exist on the table, enforces PRIMARY key constraint
   * and validates all values according to their column's data type
   * @param columnNames The columns to insert into
   * @param values The values to be inserted
   */
  private validateValues(columnNames: string[], values: any[][]) {
    let hasPrimaryKey = false;

    columnNames.forEach((columnName, i) => {
      if (!this.schema.columns[columnName]) {
        throw new Error(
          `Column "${columnName}" does not exist in ${this.name}`
        );
      }

      hasPrimaryKey = hasPrimaryKey || this.schema.primaryKey === columnName;
    });

    if (!hasPrimaryKey) {
      // Throw error if the primary key column name is not among the provided column names
      // TODO: This behavior should change if primary key is autogenerated
      throw new Error(
        `NULL value in column ${this.schema.primaryKey} violates PRIMARY KEY constraint`
      );
    }

    const validRows: TableRow[] = [];
    const tempUnique: Record<string, Record<string, boolean>> = {};

    values.forEach((valuesRow) => {
      const row: TableRow = {};

      valuesRow.forEach((value, i) => {
        const columnName = columnNames[i];
        if (!columnName) {
          throw new Error("INSERT has more expressions than target columns");
        }
        row[columnName] = value;

        if (columnName === this.schema.primaryKey) {
          // Ensure that Primary key is unique and NOT NULL
          if (!value) {
            throw new Error(`Primary key "${columnName}" cannot be null`);
          }

          if (
            (this.unique[columnName] && this.unique[columnName][value]) ||
            (tempUnique[columnName] && tempUnique[columnName][value])
          ) {
            throw new Error(`Duplicate value for Primary key "${columnName}"`);
          }
        }

        const uniqueEntry: Record<string, boolean> = {};
        uniqueEntry[value] = true;
        tempUnique[columnName] = uniqueEntry;
      });

      validRows.push(row);
    });

    this.unique = { ...this.unique, ...tempUnique };
    return validRows;
  }

  insert(columnNames: string[], values: any[]) {
    const validRows = this.validateValues(columnNames, values);
    this.rows.push(...validRows);
  }

  select(columnNames: string[], whereFn = (r: TableRow) => true): TableRow[] {
    const result: TableRow[] = [];

    if (columnNames.length === 1 && columnNames[0] === "*") {
      columnNames = Object.keys(this.schema.columns);
    }

    this.rows.forEach((row) => {
      if (whereFn(row)) {
        const resultRow: TableRow = {};
        columnNames.forEach((columnName) => {
          if (!this.schema.columns[columnName]) {
            throw new Error(
              `Column "${columnName}" does not exist in ${this.name}`
            );
          }
          resultRow[columnName] = row[columnName];
        });
        result.push(resultRow);
      }
    });

    return result;
  }

  update(columns: ColumnToUpdate[], whereFn = (r: TableRow) => true): number {
    // Validate columns
    columns.forEach((column) => {
      if (!this.schema.columns[column.column]) {
        throw new Error(
          `Column "${column.column}" does not exist in ${this.name}`
        );
      }
    });

    let rowsAffected = 0;

    this.rows.forEach((row) => {
      if (whereFn(row)) {
        columns.forEach((column) => {
          row[column.column] = column.value;
        });
        rowsAffected++;
      }
    });

    return rowsAffected;
  }

  delete(whereFn = (r: TableRow) => true): number {
    let rowsAffected = 0;

    this.rows = this.rows.filter((row) => {
      if (whereFn(row)) {
        rowsAffected++;
        return false;
      }
      return true;
    });

    return rowsAffected;
  }
}
